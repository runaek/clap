package derive

import (
	"fmt"
	"io"
	"strings"
	"text/template"
)

func NewTemplate() Template {
	return Template{
		NameUsage:        "Name of the Deriver.",
		ParserUsage:      "The parse.Parse[T] implementation to be used.",
		DataTypeUsage:    "Go data-type to be handled by the Deriver.",
		ParserPkgUsage:   "The go-package containing the parse.Parse[T] implementation.",
		ParserPkgDefault: "github.com/runaek/clap/pkg/parse",
		PkgUsage:         "The name of the go-package for the template.",
		PkgDefault:       "derive",
	}
}

// A Template for a simple Deriver implementation.
//
// This can be used to generate code for a Deriver implementation and register it for use.
type Template struct {
	// Name of the Deriver
	Name      string `cli:"!#1:string"`
	NameUsage string

	Title string

	// DataType is the name of the data-types handled by the Deriver
	DataType      string `cli:"!#2:string"`
	DataTypeUsage string

	// Parser is the full name of the parse.Parse[T] implementation
	Parser      string `cli:"!-parser|P:string"`
	ParserUsage string

	// ParserPkg is the name of the package to be imported containing the Parser
	ParserPkg        string `cli:"-pkg-import:string"`
	ParserPkgUsage   string
	ParserPkgDefault string

	// Pkg is the name of the Go-package for the template
	Pkg        string `cli:"!-pkg:string"`
	PkgUsage   string
	PkgDefault string
}

func (dat Template) Process(out io.Writer) error {
	if len(dat.Name) > 1 {
		dat.Title = fmt.Sprintf("%s%s", strings.ToTitle(dat.Name[:1]), dat.Name[1:])
	}

	tpl, err := template.New("deriver").Parse(deriverCodeTemplate)

	if err != nil {
		return err
	}

	return tpl.Execute(out, dat)
}

const (
	deriverCodeTemplate = `// Code generated by github.com/runaek/clap/cmd/generate_drivers. DO NOT EDIT

package {{ .Pkg }} 

import (
	"fmt"
	"github.com/runaek/clap"
	"{{ .ParserPkg }}"
)

const (
	Err{{ .Title }} clap.Error = "unable to derive '{{ .Name }}' Argument"
)

type {{ .Name }}Deriver struct {}

func (_ {{ .Name }}Deriver) DeriveKeyValue(a any, s string, opts ...clap.Option) (clap.IKeyValue, error) {
	v, ok := a.(*{{ .DataType  }})
	
	if !ok {
		return nil, fmt.Errorf("%w: want *{{ .DataType }} but got %T", Err{{ .Title }}, v)
	}

	return clap.NewKeyValue[{{ .DataType }}](v, s, {{ .Parser }}{}, opts...), nil 
}

func (_ {{ .Name }}Deriver) DerivePosition(a any, s int, opts ...clap.Option) (clap.IPositional, error) {
	v, ok := a.(*{{ .DataType  }})

	if !ok {
		return nil, fmt.Errorf("%w: want *{{ .DataType }} but got %T", Err{{ .Title }}, v)
	}

	return clap.NewPosition[{{ .DataType }}](v, s, {{ .Parser }}{}, opts...), nil 
}

func (_ {{ .Name }}Deriver) DeriveFlag(a any, s string, opts ...clap.Option) (clap.IFlag, error) {
	v, ok := a.(*{{ .DataType  }})

	if !ok {
		return nil, fmt.Errorf("%w: want *{{ .DataType }} but got %T", Err{{ .Title }}, v)
	}

	return clap.NewFlag[{{ .DataType }}](v, s, {{ .Parser }}{}, opts...), nil 
}

func init() {
	clap.RegisterFlagDeriver("{{ .Name }}", {{ .Name }}Deriver{})
	clap.RegisterPositionalDeriver("{{ .Name }}", {{ .Name }}Deriver{})
	clap.RegisterKeyValueDeriver("{{ .Name }}", {{ .Name }}Deriver{})
}
`
)
