package derive

import (
	"fmt"
	"io"
	"strings"
	"text/template"
)

func NewTemplate() Template {
	return Template{
		NameUsage:        "Name of the Deriver.",
		ParserUsage:      "The parse.Parse[T] implementation to be used.",
		DataTypeUsage:    "Go data-type to be handled by the Deriver.",
		ParserPkgUsage:   "The go-package containing the parse.Parse[T] implementation.",
		ParserPkgDefault: "github.com/runaek/clap/pkg/parse",
		PkgUsage:         "The name of the go-package for the template.",
		PkgDefault:       "derive",
		PositionUsage:    "When specified, generate stubs for a PositionalDeriver.",
		KeyValueUsage:    "When specified, generate stubs for a KeyValueDeriver.",
		FlagUsage:        "When specified, generate stubs for a FlagDeriver.",
	}
}

// A Template for a simple Deriver implementation.
//
// This can be used to generate code for a Deriver implementation and register it for use.
type Template struct {
	// Name of the Deriver
	Name      string `cli:"!#1:string"`
	NameUsage string

	Position      bool `cli:"-pos|P:bool"`
	PositionUsage string

	KeyValue      bool `cli:"-key|K:bool"`
	KeyValueUsage string

	Flag      bool `cli:"-flag|F:bool"`
	FlagUsage string

	Title string

	// DataType is the name of the data-types handled by the Deriver
	DataType      string `cli:"!#2:string"`
	DataTypeUsage string

	// Parser is the full name of the parse.Parse[T] implementation
	Parser      string `cli:"!-parser:string"`
	ParserUsage string

	// ParserPkg is the name of the package to be imported containing the Parser
	ParserPkg        string `cli:"-pkg-import:string"`
	ParserPkgUsage   string
	ParserPkgDefault string

	// Pkg is the name of the Go-package for the template
	Pkg        string `cli:"!-pkg:string"`
	PkgUsage   string
	PkgDefault string
}

func (dat Template) Process(out io.Writer) error {
	if len(dat.Name) > 1 {
		dat.Title = fmt.Sprintf("%s%s", strings.ToTitle(dat.Name[:1]), dat.Name[1:])
	}

	tpl, err := template.New("deriver").Parse(deriverCodeTemplate)

	if err != nil {
		return err
	}

	if !(dat.Flag || dat.Position || dat.KeyValue) {
		dat.Flag = true
		dat.Position = true
		dat.KeyValue = true
	}

	return tpl.Execute(out, dat)
}

const (
	deriverCodeTemplate = `// Code generated by github.com/runaek/clap/cmd/generate_drivers. DO NOT EDIT

package {{ .Pkg }}

import (
	"fmt"
	"github.com/runaek/clap"
	"{{ .ParserPkg }}"
)

const (
	Err{{ .Title }} clap.Error = "unable to derive '{{ .Name }}' Argument"
)

type {{ .Name }}Deriver struct{}

{{- if .KeyValue }}

func (_ {{ .Name }}Deriver) DeriveKeyValue(a any, s string, opts ...clap.Option) (clap.IKeyValue, error) {
	v, ok := a.(*{{ .DataType  }})

	if !ok {
		return nil, fmt.Errorf("%w: want *{{ .DataType }} but got %T", Err{{ .Title }}, v)
	}

	return clap.NewKeyValue[{{ .DataType }}](v, s, {{ .Parser }}{}, opts...), nil
}
{{- end -}}

{{- if .Position }}

func (_ {{ .Name }}Deriver) DerivePosition(a any, s int, opts ...clap.Option) (clap.IPositional, error) {
	v, ok := a.(*{{ .DataType  }})

	if !ok {
		return nil, fmt.Errorf("%w: want *{{ .DataType }} but got %T", Err{{ .Title }}, v)
	}

	return clap.NewPosition[{{ .DataType }}](v, s, {{ .Parser }}{}, opts...), nil
}
{{- end }}

{{- if .Flag }}

func (_ {{ .Name }}Deriver) DeriveFlag(a any, s string, opts ...clap.Option) (clap.IFlag, error) {
	v, ok := a.(*{{ .DataType  }})

	if !ok {
		return nil, fmt.Errorf("%w: want *{{ .DataType }} but got %T", Err{{ .Title }}, v)
	}

	return clap.NewFlag[{{ .DataType }}](v, s, {{ .Parser }}{}, opts...), nil
}
{{- end }}

func init() {
{{- if .Flag }}
	clap.RegisterFlagDeriver("{{ .Name }}", {{ .Name }}Deriver{})
{{- end }}

{{- if .Position }}
	clap.RegisterPositionalDeriver("{{ .Name }}", {{ .Name }}Deriver{})
{{- end }}

{{- if .KeyValue }}
	clap.RegisterKeyValueDeriver("{{ .Name }}", {{ .Name }}Deriver{})
{{- end }}
}`
)
